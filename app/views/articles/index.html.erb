<div class="search-container">
  <h1>Instant Article Search</h1>
  
  <div class="search-form">
    <div class="search-input-container">
      <input type="text" id="search-input" placeholder="Search articles...">
      <button id="clear-search" class="clear-button">&times;</button>
    </div>
  </div>
  
  <div class="results-info">
    <p id="results-count">Showing <span id="count">0</span> articles</p>
  </div>
  
  <div id="search-results" class="articles-list"></div>
  
  <div id="search-analytics" class="analytics-container">
    <h2>Search Analytics</h2>
    
    <div class="search-summary">
      <div class="summary-item">
        <span class="summary-label">Total Search:</span>
        <span id="unique-terms" class="summary-value">0</span>
      </div>
      <div class="summary-item">
        <span class="summary-label">Total Searched Articles:</span>
        <span id="articles-found" class="summary-value">0</span>
      </div>
      <div class="summary-item">
        <span class="summary-label">Total Search Appearances:</span>
        <span id="total-appearances" class="summary-value">0</span>
      </div>
    </div>

    <div class="analytics-card full-width">
      <h3>Result Articles</h3>
      <div class="table-container">
        <table id="result-articles">
          <thead>
            <tr>
              <th>Article Title</th>
              <th>Category</th>
              <th>Search Appearances</th>
            </tr>
          </thead>
          <tbody>
            <!-- Will be populated dynamically -->
          </tbody>
        </table>
      </div>
    </div>
    
    <div class="analytics-tables">
      <div class="analytics-card full-width">
        <h3>Search Term Analysis</h3>
        <div class="table-container">
          <table id="search-terms">
            <thead>
              <tr>
                <th>Search Term</th>
                <th>Times Searched</th>
                <th>Results Count</th>
                <th>Last Searched</th>
              </tr>
            </thead>
            <tbody>
              <!-- Will be populated dynamically -->
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const searchInput = document.getElementById('search-input');
    const searchResults = document.getElementById('search-results');
    const resultsCount = document.getElementById('count');
    const clearButton = document.getElementById('clear-search');
    const uniqueTermsElem = document.getElementById('unique-terms');
    const articlesFoundElem = document.getElementById('articles-found');
    const totalAppearancesElem = document.getElementById('total-appearances');
    const searchTermsTable = document.getElementById('search-terms').querySelector('tbody');
    const resultArticlesTable = document.getElementById('result-articles').querySelector('tbody');
    
    let allArticles = [];
    let debounceTimer;
    let searchHistory = [];
    let currentSearchTerm = '';
    let isTyping = false;
    let typingTimer;
    
    // Analytics data
    let totalSearches = 0;
    let articleAppearances = {};
    let searchTermStats = {};
    let userIdentifier = '';
    
    // Load all articles initially
    function loadAllArticles() {
      fetch('/articles.json')
        .then(response => response.json())
        .then(articles => {
          allArticles = articles;
          displayArticles(articles);
          
          // Load analytics data from the server
          loadAnalyticsData();
        })
        .catch(error => console.error('Error loading articles:', error));
    }
    
    // Load analytics data from the server
    function loadAnalyticsData() {
      console.log("Loading analytics data from server...");
      
      return fetch('/articles/analytics.json')
        .then(response => {
          if (!response.ok) {
            console.error(`Error response from analytics endpoint: ${response.status}`);
            throw new Error(`Server responded with status: ${response.status}`);
          }
          return response.json();
        })
        .then(data => {
          console.log("Analytics data received:", data);
          
          // Store user identifier but don't display it
          if (data.user_identifier) {
            userIdentifier = data.user_identifier;
            console.log("User identifier set:", userIdentifier);
            // Ensure the ID is saved to localStorage
            ensureLocalUserIdentifier();
          }
          
          // Update the tables with data from the server
          updateTablesFromServerData(data);
          return data; // Return the data for chaining
        })
        .catch(error => {
          console.error('Error loading analytics:', error);
          // Set default values in case of error
          uniqueTermsElem.textContent = '0';
          articlesFoundElem.textContent = '0';
          totalAppearancesElem.textContent = '0';
          
          // Show error message in tables
          showErrorInTable(searchTermsTable, 4, 'Could not load search analytics');
          showErrorInTable(resultArticlesTable, 3, 'Could not load article analytics');
          throw error; // Re-throw for proper promise chaining
        });
    }
    
    // Update tables with server data
    function updateTablesFromServerData(data) {
      // Update search terms table
      updateSearchTermsTableFromServer(data.top_searches);
      
      // Update article appearances table
      updateResultArticlesTableFromServer(data.top_articles);
      
      // Update summary metrics
      if (data.stats) {
        // If server provided statistics data, use it
        uniqueTermsElem.textContent = data.stats.total_unique_searches || '0';
        articlesFoundElem.textContent = data.stats.total_articles_found || '0';
        totalAppearancesElem.textContent = data.stats.total_appearances || '0';
      } else {
        // Fall back to client-side calculation if server stats not available
        if (data.top_searches && data.top_searches.length > 0) {
          uniqueTermsElem.textContent = data.top_searches.length;
        } else {
          uniqueTermsElem.textContent = '0';
        }
        
        if (data.top_articles && data.top_articles.length > 0) {
          articlesFoundElem.textContent = data.top_articles.length;
          
          // Calculate total appearances across all articles
          const totalAppearances = data.top_articles.reduce((sum, article) => sum + (parseInt(article.appearances) || 0), 0);
          totalAppearancesElem.textContent = totalAppearances;
        } else {
          articlesFoundElem.textContent = '0';
          totalAppearancesElem.textContent = '0';
        }
      }
    }
    
    // Update search terms table from server data
    function updateSearchTermsTableFromServer(topSearches) {
      searchTermsTable.innerHTML = '';
      
      if (topSearches.length === 0) {
        const emptyRow = document.createElement('tr');
        const emptyCell = document.createElement('td');
        emptyCell.colSpan = 4;
        emptyCell.textContent = 'No search term statistics available yet';
        emptyCell.className = 'empty-table';
        emptyRow.appendChild(emptyCell);
        searchTermsTable.appendChild(emptyRow);
        return;
      }
      
      topSearches.forEach(search => {
        const row = document.createElement('tr');
        
        const termCell = document.createElement('td');
        termCell.textContent = search.term;
        
        const countCell = document.createElement('td');
        countCell.textContent = search.count;
        
        const resultsCell = document.createElement('td');
        resultsCell.textContent = search.results;
        
        const lastSearchedCell = document.createElement('td');
        lastSearchedCell.textContent = new Date(search.last_searched).toLocaleString();
        
        row.appendChild(termCell);
        row.appendChild(countCell);
        row.appendChild(resultsCell);
        row.appendChild(lastSearchedCell);
        
        searchTermsTable.appendChild(row);
      });
    }
    
    // Update result articles table from server data
    function updateResultArticlesTableFromServer(topArticles) {
      resultArticlesTable.innerHTML = '';
      
      if (topArticles.length === 0) {
        const emptyRow = document.createElement('tr');
        const emptyCell = document.createElement('td');
        emptyCell.colSpan = 3;
        emptyCell.textContent = 'No article appearance statistics available yet';
        emptyCell.className = 'empty-table';
        emptyRow.appendChild(emptyCell);
        resultArticlesTable.appendChild(emptyRow);
        return;
      }
      
      topArticles.forEach(article => {
        const row = document.createElement('tr');
        
        const titleCell = document.createElement('td');
        titleCell.textContent = article.title;
        
        const categoryCell = document.createElement('td');
        categoryCell.textContent = article.category;
        
        const appearancesCell = document.createElement('td');
        appearancesCell.textContent = article.appearances;
        
        row.appendChild(titleCell);
        row.appendChild(categoryCell);
        row.appendChild(appearancesCell);
        
        resultArticlesTable.appendChild(row);
      });
    }
    
    // Search articles with better handling of search state
    function searchArticles(query, isFinalSearch = false) {
      console.log(`Searching for "${query}" (final: ${isFinalSearch})`);
      
      // Track this search attempt
      trackSearchAttempt(query, isFinalSearch);
      
      if (query.trim() === '') {
        console.log("Empty query, loading all articles");
        loadAllArticles();
        return;
      }
      
      // Set search in progress flag
      window.searchInProgress = true;
      
      const searchUrl = `/articles/search?query=${encodeURIComponent(query)}&is_final=${isFinalSearch ? 'true' : 'false'}`;
      console.log(`Fetching: ${searchUrl}`);
      
      return fetch(searchUrl)
        .then(response => {
          if (!response.ok) {
            console.error(`Server responded with status: ${response.status}`);
            throw new Error(`Server responded with status: ${response.status}`);
          }
          return response.json();
        })
        .then(data => {
          console.log(`Search results:`, data);
          displayArticles(data.articles || []);
          window.searchInProgress = false;
          
          // Store user identifier but don't display it
          if (data.analytics && data.analytics.user_identifier) {
            userIdentifier = data.analytics.user_identifier;
          }
          
          if (isFinalSearch) {
            console.log("Final search - updating statistics and analytics");
            // Update article statistics
            updateArticleStats(data.articles || [], query);
            
            // Reload analytics data immediately after a final search
            return loadAnalyticsData().then(() => {
              // Scroll to analytics section for visibility
              document.getElementById('search-analytics').scrollIntoView({ behavior: 'smooth' });
              // Highlight the analytics section briefly to draw attention
              const analyticsSection = document.getElementById('search-analytics');
              analyticsSection.classList.add('highlight-analytics');
              setTimeout(() => {
                analyticsSection.classList.remove('highlight-analytics');
              }, 1500);
              
              return data;
            });
          }
          
          return data;
        })
        .catch(error => {
          console.error('Error searching articles:', error);
          searchResults.innerHTML = '<p class="no-results error-message">An error occurred while searching. Please try again.</p>';
          resultsCount.textContent = '0';
          window.searchInProgress = false;
          throw error;
        });
    }
    
    // Track search attempt using a queue to ensure we don't miss any searches
    const searchQueue = [];
    let processingQueue = false;
    
    function trackSearchAttempt(query, isFinal) {
      // Add search to queue
      searchQueue.push({ query, isFinal, timestamp: Date.now() });
      
      // Process queue if not already processing
      if (!processingQueue) {
        processSearchQueue();
      }
    }
    
    function processSearchQueue() {
      if (searchQueue.length === 0) {
        processingQueue = false;
        return;
      }
      
      processingQueue = true;
      
      // Get next search
      const search = searchQueue.shift();
      
      // For final searches, we want to add them to our local storage for resilience
      if (search.isFinal) {
        // Save to local storage for offline resilience
        const savedSearches = JSON.parse(localStorage.getItem('pendingSearches') || '[]');
        savedSearches.push(search);
        localStorage.setItem('pendingSearches', JSON.stringify(savedSearches));
        
        // Also track in session
        addToSearchHistory(search.query);
        
        // Increment total searches counter
        totalSearches++;
        
        // Update search term statistics
        updateSearchTermStats(search.query);
      }
      
      // Process next item in queue with a small delay
      setTimeout(processSearchQueue, 50);
    }
    
    // Event handler for blur/focus to detect when user leaves the page
    window.addEventListener('blur', () => {
      // When user leaves the page, force any current search to become final
      if (currentSearchTerm && currentSearchTerm.trim() !== '') {
        console.log(`User left page, finalizing search: "${currentSearchTerm}"`);
        clearTimeout(typingTimer);
        searchArticles(currentSearchTerm, true);
      }
    });
    
    // Set up event listener for search input with improved debounce and final search detection
    searchInput.addEventListener('input', () => {
      clearTimeout(debounceTimer);
      clearTimeout(typingTimer);
      
      // Update the current search term
      currentSearchTerm = searchInput.value.trim();
      
      // If the input is empty, immediately load all articles
      if (currentSearchTerm === '') {
        console.log("Input cleared, loading all articles");
        loadAllArticles();
        return;
      }
      
      // Mark as typing
      isTyping = true;
      console.log(`User typing: "${currentSearchTerm}"`);
      
      // Set a timer to detect when user stops typing - this makes a search final
      typingTimer = setTimeout(() => {
        isTyping = false;
        console.log(`User stopped typing for 1 second: "${currentSearchTerm}"`);
        
        // If the user has stopped typing, send the final search regardless of length
        if (currentSearchTerm.length > 0) {
          console.log(`Sending final search: "${currentSearchTerm}"`);
          // Show debug alert for final search
          const finalSearchMsg = document.createElement('div');
          finalSearchMsg.className = 'final-search-alert';
          finalSearchMsg.textContent = `Final search: "${currentSearchTerm}"`;
          document.body.appendChild(finalSearchMsg);
          setTimeout(() => {
            finalSearchMsg.remove();
          }, 3000);
          
          searchArticles(currentSearchTerm, true);
        } else {
          // If they cleared the input and stopped typing, load all articles
          console.log("Input is empty after typing stopped, loading all articles");
          loadAllArticles();
        }
      }, 1000); // 1 second of no typing means they finished
      
      // Implement an adaptive debounce for intermediate searches
      // Use a shorter debounce for faster typists (based on time between keystrokes)
      const now = Date.now();
      const timeSinceLastInput = now - (lastInputTime || now);
      lastInputTime = now;
      
      // Determine debounce delay based on typing speed
      // Fast typists get shorter debounce, slow typists get longer
      let debounceDelay = 300; // Default
      if (timeSinceLastInput < 100) {
        // Fast typist
        debounceDelay = 200;
      } else if (timeSinceLastInput > 500) {
        // Slow typist
        debounceDelay = 400;
      }
      
      // Still use debounce for continuous feedback
      debounceTimer = setTimeout(() => {
        const query = currentSearchTerm;
        
        // If query is empty load all articles, otherwise search
        if (query.length === 0) {
          console.log("Debounce: Empty query, loading all articles");
          loadAllArticles();
          return;
        }
        
        // Only do intermediate search if still typing and not already searching
        if (isTyping && !window.searchInProgress) {
          console.log(`Intermediate search while typing: "${query}" (debounce: ${debounceDelay}ms)`);
          searchArticles(query, false);
        }
      }, debounceDelay);
    });
    
    // Display articles in the DOM
    function displayArticles(articles) {
      searchResults.innerHTML = '';
      resultsCount.textContent = articles.length;
      
      if (articles.length === 0) {
        searchResults.innerHTML = '<p class="no-results">No articles found matching your search.</p>';
        return;
      }
      
      articles.forEach(article => {
        const articleElement = document.createElement('div');
        articleElement.className = 'article-item';
        
        const header = document.createElement('div');
        header.className = 'article-header';
        
        const title = document.createElement('h2');
        title.textContent = article.title;
        
        const categoryElem = document.createElement('span');
        categoryElem.className = 'category-tag';
        categoryElem.textContent = article.category;
        
        header.appendChild(title);
        header.appendChild(categoryElem);
        
        const meta = document.createElement('div');
        meta.className = 'article-meta';
        
        const author = document.createElement('span');
        author.className = 'author';
        author.textContent = `By ${article.author}`;
        
        const date = document.createElement('span');
        date.className = 'date';
        date.textContent = new Date(article.created_at).toLocaleDateString();
        
        meta.appendChild(author);
        meta.appendChild(date);
        
        const content = document.createElement('p');
        content.className = 'content';
        content.textContent = truncateText(article.content, 200);
        
        articleElement.appendChild(header);
        articleElement.appendChild(meta);
        articleElement.appendChild(content);
        
        searchResults.appendChild(articleElement);
      });
    }
    
    // Update article statistics
    function updateArticleStats(articles, query) {
      articles.forEach(article => {
        if (!articleAppearances[article.id]) {
          articleAppearances[article.id] = {
            title: article.title,
            category: article.category,
            appearances: 0
          };
        }
        
        articleAppearances[article.id].appearances++;
      });
    }
    
    // Update search term statistics
    function updateSearchTermStats(query) {
      if (query.trim() === '') return;
      
      const normalizedQuery = query.toLowerCase().trim();
      
      if (!searchTermStats[normalizedQuery]) {
        searchTermStats[normalizedQuery] = {
          term: query,
          count: 0,
          results: [],
          lastSearched: null
        };
      }
      
      searchTermStats[normalizedQuery].count++;
      searchTermStats[normalizedQuery].lastSearched = new Date();
      
      // Update unique terms count
      uniqueTermsElem.textContent = Object.keys(searchTermStats).length;
    }
    
    // Add to search history
    function addToSearchHistory(query) {
      if (query.trim() === '') return;
      
      // Add to the beginning of the array
      searchHistory.unshift(query);
      
      // Keep only the last 5 searches
      searchHistory = searchHistory.slice(0, 5);
    }
    
    // Truncate text to a specific length
    function truncateText(text, maxLength) {
      if (text.length <= maxLength) return text;
      return text.substr(0, maxLength) + '...';
    }
    
    // Function to clear the search and show all articles
    function clearSearch() {
      searchInput.value = '';
      currentSearchTerm = '';
      loadAllArticles();
    }
    
    // Add click handler for clear button
    clearButton.addEventListener('click', clearSearch);
    
    // Add keyup handler for Escape key
    searchInput.addEventListener('keyup', (e) => {
      if (e.key === 'Escape') {
        clearSearch();
      }
    });
    
    // Show/hide clear button based on input content
    searchInput.addEventListener('input', () => {
      if (searchInput.value.trim() === '') {
        clearButton.style.display = 'none';
      } else {
        clearButton.style.display = 'block';
      }
    });
    
    // Initially hide the clear button
    clearButton.style.display = 'none';
    
    // Add event listener for clearing the search box (e.g., when user hits Esc or clear button)
    searchInput.addEventListener('search', () => {
      if (searchInput.value.trim() === '') {
        loadAllArticles();
      }
    });
    
    // Helper function to show errors in tables
    function showErrorInTable(tableBody, colSpan, message) {
      tableBody.innerHTML = '';
      const emptyRow = document.createElement('tr');
      const emptyCell = document.createElement('td');
      emptyCell.colSpan = colSpan;
      emptyCell.textContent = message;
      emptyCell.className = 'empty-table error-message';
      emptyRow.appendChild(emptyCell);
      tableBody.appendChild(emptyRow);
    }
    
    // Initialize the lastInputTime variable
    let lastInputTime = Date.now();
    
    // Process any pending offline searches
    function processPendingSearches() {
      const pendingSearches = JSON.parse(localStorage.getItem('pendingSearches') || '[]');
      
      if (pendingSearches.length === 0) {
        return;
      }
      
      console.log(`Found ${pendingSearches.length} pending searches to process`);
      
      // Only process final searches
      const finalSearches = pendingSearches.filter(s => s.isFinal);
      
      if (finalSearches.length === 0) {
        // Clear storage if no final searches
        localStorage.removeItem('pendingSearches');
        return;
      }
      
      // Submit to server
      fetch('/articles/process_pending_searches', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
        },
        body: JSON.stringify({ pending_searches: finalSearches })
      })
      .then(response => response.json())
      .then(data => {
        console.log(`Processed ${data.processed} pending searches`);
        // Clear storage
        localStorage.removeItem('pendingSearches');
        // Refresh analytics
        loadAnalyticsData();
      })
      .catch(error => {
        console.error('Error processing pending searches:', error);
      });
    }
    
    // Handle user identifier persistence
    function ensureLocalUserIdentifier() {
      // Check if we have a user ID from localStorage
      let localUserId = localStorage.getItem('userIdentifier');
      
      // If we received a user ID from the server, use and save it
      if (userIdentifier) {
        // If the server sent us a user ID, save it to localStorage
        localStorage.setItem('userIdentifier', userIdentifier);
        return;
      }
      
      // If we have a local ID but not a server ID, send it to the server
      if (localUserId && !userIdentifier) {
        // Send the local ID to the server on next request
        fetch(`/articles/set_user_identifier?user_id=${encodeURIComponent(localUserId)}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
          }
        })
        .then(response => {
          if (response.ok) {
            console.log('User identifier synchronized with server');
            // Reload to get updated analytics with the proper user ID
            loadAnalyticsData();
          }
        })
        .catch(error => console.error('Error syncing user ID:', error));
      }
    }
    
    // Initial load
    function initialize() {
      // Load all articles
      loadAllArticles();
      
      // Process any pending searches from previous sessions
      processPendingSearches();
      
      // Add this near the end, after other initialization
      ensureLocalUserIdentifier();
      
      // Add event listener for online/offline status
      window.addEventListener('online', handleOnlineStatusChange);
      window.addEventListener('offline', handleOnlineStatusChange);
    }
    
    // Handle online/offline status changes
    function handleOnlineStatusChange(event) {
      if (navigator.onLine) {
        console.log('Back online - processing any pending searches');
        processPendingSearches();
      } else {
        console.log('Offline - searches will be stored locally');
      }
    }
    
    // Initialize the application
    initialize();
  });
</script>

<style>
  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }
  
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background-color: #f8f9fa;
    color: #333;
    line-height: 1.6;
  }
  
  .search-container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
  }
  
  h1 {
    text-align: center;
    margin: 20px 0 30px;
    color: #2c3e50;
    font-size: 2.5rem;
  }
  
  h2 {
    margin: 30px 0 20px;
    color: #2c3e50;
    font-size: 1.8rem;
    text-align: center;
  }
  
  h3 {
    margin-bottom: 15px;
    color: #34495e;
    font-size: 1.2rem;
  }
  
  .search-form {
    margin-bottom: 20px;
    max-width: 600px;
    margin: 0 auto 30px;
  }
  
  .search-input-container {
    position: relative;
    width: 100%;
  }
  
  #search-input {
    width: 100%;
    padding: 15px 40px 15px 15px;
    font-size: 16px;
    border: none;
    border-radius: 30px;
    background-color: white;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    transition: all 0.3s ease;
  }
  
  #search-input:focus {
    outline: none;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
  }
  
  .clear-button {
    position: absolute;
    right: 15px;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    font-size: 20px;
    color: #999;
    cursor: pointer;
    padding: 5px;
    display: none;
  }
  
  .clear-button:hover {
    color: #666;
  }
  
  .results-info {
    text-align: center;
    margin-bottom: 30px;
    color: #666;
    font-size: 1.1rem;
  }
  
  /* Article list styles */
  .articles-list {
    margin-bottom: 40px;
  }
  
  .article-item {
    background-color: white;
    border-left: 4px solid #3498db;
    padding: 20px;
    margin-bottom: 15px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
    transition: transform 0.2s ease, box-shadow 0.2s ease;
  }
  
  .article-item:hover {
    transform: translateX(5px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  }
  
  .article-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 10px;
  }
  
  .article-header h2 {
    margin: 0;
    font-size: 1.4rem;
    color: #2c3e50;
    flex: 1;
    text-align: left;
  }
  
  .article-meta {
    display: flex;
    color: #7f8c8d;
    font-size: 0.9rem;
    margin-bottom: 15px;
  }
  
  .author {
    margin-right: 15px;
  }
  
  .category-tag {
    display: inline-block;
    background-color: #e9f5ff;
    color: #3498db;
    font-size: 0.8rem;
    font-weight: bold;
    padding: 3px 10px;
    border-radius: 15px;
    white-space: nowrap;
    margin-left: 10px;
  }
  
  .content {
    color: #555;
    line-height: 1.6;
  }
  
  .no-results {
    text-align: center;
    padding: 40px;
    color: #7f8c8d;
    font-style: italic;
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
  }
  
  /* Analytics styles */
  .analytics-container {
    margin-top: 50px;
    border-top: 1px solid #eee;
    padding-top: 30px;
  }
  
  .search-summary {
    display: flex;
    justify-content: space-around;
    margin-bottom: 30px;
    padding: 15px;
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
  }
  
  .summary-item {
    text-align: center;
  }
  
  .summary-label {
    display: block;
    font-size: 0.9rem;
    color: #7f8c8d;
    margin-bottom: 5px;
  }
  
  .summary-value {
    font-size: 1.8rem;
    font-weight: bold;
    color: #2c3e50;
  }
  
  .analytics-tables {
    margin-top: 30px;
  }
  
  .analytics-card {
    background-color: white;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
  }
  
  .analytics-card.full-width {
    margin-bottom: 20px;
  }
  
  .table-container {
    overflow-x: auto;
    margin-top: 15px;
  }
  
  table {
    width: 100%;
    border-collapse: collapse;
  }
  
  th, td {
    padding: 12px 15px;
    text-align: left;
    border-bottom: 1px solid #eee;
  }
  
  th {
    background-color: #f8f9fa;
    color: #34495e;
    font-weight: 600;
    position: sticky;
    top: 0;
  }
  
  tbody tr:hover {
    background-color: #f5f9ff;
  }
  
  .empty-table {
    text-align: center;
    color: #95a5a6;
    font-style: italic;
    padding: 20px;
  }
  
  /* Responsive styles */
  @media (max-width: 768px) {
    .search-summary {
      flex-direction: column;
      gap: 15px;
    }
    
    h1 {
      font-size: 2rem;
    }
    
    h2 {
      font-size: 1.5rem;
    }
    
    .article-header {
      flex-direction: column;
    }
    
    .category-tag {
      margin-left: 0;
      margin-top: 5px;
    }
    
    th, td {
      padding: 8px 10px;
      font-size: 0.9rem;
    }
  }
  
  .user-info-card {
    background-color: white;
    border-radius: 8px;
    padding: 20px;
    margin-bottom: 30px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    display: flex;
    justify-content: space-around;
  }
  
  .user-info-item {
    text-align: center;
  }
  
  .info-label {
    display: block;
    font-size: 0.9rem;
    color: #7f8c8d;
    margin-bottom: 5px;
  }
  
  .info-value {
    font-size: 1.2rem;
    font-weight: bold;
    color: #2c3e50;
    word-break: break-all;
  }
  
  .error-message {
    color: #e74c3c;
  }
  
  /* Animation for analytics update */
  @keyframes highlight-pulse {
    0% { box-shadow: 0 0 0 rgba(52, 152, 219, 0); }
    50% { box-shadow: 0 0 20px rgba(52, 152, 219, 0.7); }
    100% { box-shadow: 0 0 0 rgba(52, 152, 219, 0); }
  }
  
  .highlight-analytics {
    animation: highlight-pulse 1.5s ease-in-out;
    background-color: rgba(52, 152, 219, 0.1);
    transition: background-color 1.5s ease-in-out;
  }
  
  /* Debug alert for final search */
  .final-search-alert {
    position: fixed;
    top: 20px;
    right: 20px;
    background-color: #3498db;
    color: white;
    padding: 10px 15px;
    border-radius: 5px;
    z-index: 1000;
    box-shadow: 0 3px 6px rgba(0,0,0,0.2);
    animation: slide-in 0.3s ease-out;
  }
  
  @keyframes slide-in {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }
</style> 